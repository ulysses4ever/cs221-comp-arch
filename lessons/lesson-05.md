[//]: <> ( assignment id: 10063 )

Все подпрограммы должны выполняться в конвенциях **cdecl** (см.
[прошлую лабораторную](http://edu.mmcs.sfedu.ru/mod/assign/view.php?id=9881)).
Обратите внимание, что в этой работе, последней перед контрольной работой,
не указано, какие имена использовать для файлов и подпрограмм: следует подходить
к их выбору обдуманно.

1.  [1 балл] Создайте процедуру, которая заполняет данный массив первыми _N_ (> 0)
    числами Фибоначчи. Число _N_ — параметр подпрограммы. В основной
    программе следует распечатать результирующий массив.

    **Указания.** Если _N_ = 0, то делать ничего не надо. Далее проверяются
    специальные случаи _N_ = 1 и 2. Перед каждой проверкой удобно уменьшать _N_,
    это позволит сравнивать _N_ с 0 и подготовит счётчик будущего цикла, если
    _N_ > 2. Если _N_ = 0, 1, 2,, то должны совершаться джампы к эпилогу подпрограммы.

    **Дополнительное требование.** После того, как подпрограмма заработает,
    выделите подпрограмму печати массива в отдельный файл `print_arr.s`. Для
    ассемблирования программы из нескольких файлов следует указать их через
    пробел ассемблеру `as88`. Для запуска следует указать `s88` или `t88` имя первого файла, переданного в списке `as88` без расширения. 
    
        $ as88 task-1.s print_arr.s
        ...
        $ s88 task-1
    
    Учтите, что имена констант и меток в разных файлах
    должны быть уникальны. Первым следует указывать файл с «основной программой». В файле `print_arr.s` должны присутствовать
    все три стандартные секции для кода и данных.

2.  [2 балла] Создайте процедуру, которая по двум входным массивам заполняет данный
    третий результатом применения данной функции к соответствующим элементам 
    входных массивов

        c[i] = f([a[i], b[i])

    (`a`, `b`, `c`, `f` — параметры процедуры; кроме того, следует ввести параметр
    для длины массивов). Для проверки
    вызвать созданную процедуру с функцией `f=max` (возвращает максимум из двух элементов).
    Основную и вспомогательную (`max`) подпрограммы следует определить вместе в отдельном 
    от основной программы файле.
    Все три массива после вызова
    подпрограммы следует распечатать в основной программе с помощью функции
    печати, определённой в файле `print_arr.s`. Таким образом, ассемблировать
    следует три файла: основная программа, подпрограммы, печать.

3.  [3 балла] Создайте функцию, которая меняет порядок цифр в числе на
    противоположный. Эту функцию следует реализовать на основе вспомогательной
    процедуры `AddRightDigit(D, K)`, которая «дописывает» цифру _D_ к числу _K_
    справа. Число _K_ должно передаваться «по ссылке», то есть должен передаваться
    его адрес. Нужно учесть, что значения в регистрах не имеют адресов, потому
    в главной подпрограмме, которая ответственна за перестановку символов, будущий
    результат следует хранить в локальной переменной, чтобы для него вызывать
    в цикле `AddRightDigit`. Для выделения локальной переменной следует сделать
    `PUSH 0` после пролога. Адрес этой переменной можно получить с помощью
    прибавления некоторой константной величины в `BP`. Константную величину нужно
    посчитать самостоятельно. Внутри `AddRightDigit` косвенное обращение по адресу 
    этой переменной должно происходить при помощи регистра `BP`, так как 
    переменная изначально выделена в сегменте стека.
    
    Основная и вспомогательная подпрограммы должны быть размещены в отдельном файле.

