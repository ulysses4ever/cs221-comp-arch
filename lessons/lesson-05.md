[//]: <> ( assignment id: 10063 )

Все подпрограммы должны выполняться в конвенциях **cdecl** (см. 
[прошлую лабораторную](http://edu.mmcs.sfedu.ru/mod/assign/view.php?id=9881)).
Обратите внимание, что в этой работе, последней перед контрольной работой,
не указано, какие имена использовать для файлов и подпрограмм: следует подходить
к их выбору обдуманно.

1.  [1 балл] Создайте процедуру, которая заполняет данный массив первыми _N_ (> 0) 
    числами Фибоначчи. Число _N_ — параметр подпрограммы. В основной
    программе следует распечатать результирующий массив.
    
    **Указания.** Если _N_ = 0, то делать ничего не надо. Далее проверяются 
    специальные случаи _N_ = 1 и 2. Перед каждой проверкой удобно уменьшать _N_,
    это позволит сравнивать _N_ с 0 и подготовит счётчик будущего цикла, если 
    _N_ > 2. Если _N_ = 0, 1, 2,, то должны совершаться джампы к эпилогу подпрограммы.
    
    **Дополнительное требование.** После того, как подпрограмма заработает, 
    выделите подпрограмму печати массива в отдельный файл `print_arr.s`. Для
    ассмеблирования программы из нескольких файлов следует указать их через 
    пробел ассемблеру `as88`. Учтите, что имена констант и меток в разных файлах 
    должны быть уникальны. В файле `print_arr.s` должны присутствовать 
    необходимые секции для кода и данных.

2.  [2 балла] Создайте процедуру, которая двум входным массивам заполняет данный 
    третий максимумами из соответствующих элементов входных массивов 
    
        c[i] = max([a[i], b[i])
    
    Параметры процедуры: адреса начала трёх масивов и длина. В своей реализации
    следует вызвать функцию `max`, возвращающую максимум из двух элементов. 
    Основную и вспомогательную подпрограммы следует определить в отдельном файле.
    Все три массива после вызова 
    подпрограммы следует распечатать в основной программе с помощью функции
    печати, определённой в файле `print_arr.s`. Таким образом, ассемблировать
    следует три файла: основная программа, подпрограммы, печать.

3.  [3 балла] Создайте функцию, которая меняет порядок цифр в числе на 
    противоположный. Эту функцию следует реализовать на основе вспомогательной 
    процедуры `AddRightDigit(D, K)`, которая «дописывает» цифру _D_ к числу _K_
    справа. Число _K_ должно передаваться «по ссылке», то есть должен передаваться 
    его адрес. Нужно учесть, что значения в регистрах не имеют адресов, потому
    в главной подпрограмме, которая ответственна за перестановку символов, будущий 
    результат следует хранить в локальной переменной, чтобы для него вызывать 
    в цикле `AddRightDigit`. Для выделения локальной переменной следует сделать
    `SUB SP, 2` после пролога. Адрес этой переменной можно получить с помощью 
    прибаления некоорой константной величины в `BP`. Константную величину нужно 
    посчитать самостоятельно.

