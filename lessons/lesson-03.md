[//]: <> ( assignment id: 12641 )

### 1  Интерфейс системных вызовов, вывод на консоль [2 балла]

Программы на микрокомпьютерах («персональных компьютерах») обычно запускаются поверх операционной системы. Это позволяет осуществлять ряд операций (в первую очередь, ввод-вывод), используя интерфейс ОС и не прибегая к более низкоуровневому взаимодействию с устройствами (BIOS, прямая запись в память устройств и т. п.).

Средства ACK (as88/s88/t88) поддерживают 7 системных вызовов и 5 функций, вместе моделирующих базовые средства ввода-вывода ОС UNIX и подобных (полное перечисление см. в Приложении к книге Таненбаума). Для обращения к ним применяется одна инструкция `SYS`. При этом для указания конкретного системного вызова (функции), а также её аргументов, используется стек.

Пример системного вызова для корректного завершения программы (с явным сообщением ОС о том, что программа завершена успешно).

    _EXIT = 1
    .SECT .TEXT
            PUSH        0       ! return code
            PUSH        _EXIT
            SYS

(Секции `DATA` и `BSS` опущены для краткости). Системный вызов для завершения программы имеет номер 1 (для наглядности используется именованная константа `_EXIT`). Он имеет один аргумент: код возврата (return code); в ОС UNIX каждая программа по завершении должна сообщать ОС целое число, описывающее результат работы программы. Обычно это ноль, если программа завершилась удачно, иначе число обозначало «код ошибки», который следовало расшифровывать с помощью документации к программе.

Для вывода на консоль целых чисел следует использовать системный вызов с кодом 127. Под ним скрывается известная из языка C функция форматного вывода [`printf`](http://www.cplusplus.com/reference/cstdio/printf/) (см. [примеры](http://it.kgsu.ru/C++/c0008.html)), которая требует передачи строки, содержащей формат вывода, и аргументов, которые будут подставлены в нужные места форматной строки (если таковые имеются). Для примера смоделируем следующий вызов функции `printf` из языка C:

    printf("%d\n", 42);

на языке ассемблера `as88`:

    _PRINTF = 127
    .SECT .TEXT
            PUSH        42
            PUSH        fmt
            PUSH        _PRINTF
            SYS

    .SECT .DATA
    fmt:    .ASCIZ       "%d\n"

В этом примере показан способ объявления строковых литералов, завершающихся нулём (в стиле C) — с помощью псевдокоманды ассемблера `.ASCIZ`. При использовании `_PRINTF` следует помнить о том, что это функция: она возвращает количество выведенных символов в регистре `AX` (который, таким образом, **«портится»**).

#### Задачи

1.  [`task-1.s`, 0.5 балла] Составьте программу, которая печатает на консоль числа от 1 до 10 через пробел, а затем печатает символ перехода на новую строку (`\n`).
    
    **Указания**

    1.  Для организации цикла использовать условные переходы `J**`, а не `LOOP`.
    2.  В конце программы добавить код завершения программы (как в первом примере с `_EXIT`).
    3.  Выполнить программу с помощью `t88`, а затем **`s88`**.

2.  [`task-2.s`, 1 балл] При выполнении прошлой программы под отладчиком `t88` видно, что стек сильно захламляется в цикле — это некорректное использование стека: считается, что после того, как  данные, помещённые на стек, использованы, их следует удалить со стека. Простой и неэффективный способ очистки стека — использование инструкции `POP`. Более разумный и широко используемый способ очистки стека — непосредственное манипулирование адресом вершины стека, который хранится в регистре `SP`. Для этого следует знать одну особенность устройства стека в интелловских процессорах: **«стек растёт вниз»**. Это означает, что при добавлении элементов на стек адрес вершины стека уменьшается. И наоборот: при снятии элементов со стека адрес вершины стека увеличивается. В данном случае для снятия трёх двухбайтовых значений следует увеличить значение адреса вершины стека (регистр `SP`) на 6 (= 3x2).

    Добавьте инструкцию увеличения `SP` на 6 сразу после системного вызова, выполняемого в цикле для печати чисел. Проследите с помощью `t88`, что захламления стека теперь не происходит.

3.  [`task-3.s`, 1.5 балла] Постоянное добавление-снятие элементов с вершины стека, как в прошлой программе, не вполне эффективно, если учесть, что меняется лишь третий аргумент системного вызова (печатаемое число). Этот аргумент можно менять, используя косвенную адресацию на стеке — для неё используется регистр `BP` (в отличие от косвенной адресации в сегменте данных, для которой используются `BX`/`SI`/`DI`).

    1.  Скопируйте решение прошлой задачи, вынесите код добавления на стек аргументов и код очистки стека за границы цикла (до и после, соответственно).
    2.  Перед циклом занесите значение вершины стека в регистр `BP` для последующей косвенной адресации на стеке с целью изменения третьего аргумента системного вызова.
    3.  На каждом шаге цикла записывайте в третий аргумент на стеке очередное число для печати. Для этого используйте **косвенную адресацию со сдвигом** (знакомимся с пятым режимом адресации): `N(BP)` вместо обычной косвенной адресации `(BP)`. Здесь `N` означает необходимый сдвиг относительно вершины стека. Первый аргумент лежит на вершине стека — `(BP)`, второй аргумент — со сдвигом 2, то есть обратиться к нему можно так: `2(BP)`, третий аргумент — со сдвигом 4, обращение: `4(BP)`.
    
4.  [`task-4.s`, 2 балла] В прошлой задаче происходило обращение к одному и тому же (третьему с вершины) элементу на стеке. Постоянно указывать сдвиг в этом случае не вполне эффективно: проще сразу же, до начала цикла, увеличить значение `BP` на 4, а внутри цикла использовать обычную косвенную адресацию `(BP)` без сдвига. Выполните это преобразование программы.

### 2  Простейшие подпрограммы [1 балл]

Чтобы создать программу, использующую подпрограмму (процедуру или функцию), нужно должным образом организовать две части программы: код вызова подпрограммы (из основной программы) и код самой подпрограммы.

Код вызова очень похож на код осуществления системного вызова: необходимые параметры (обычно) складываются на стек, а затем используется инструкция

            CALL    <имя_метки_подпрограммы>

В этом месте происходит непосредственно вызов подпрограммы. После её окончания продолжается выполнение инструкций, следующих за CALL. Обычно первая такая инструкция состоит в очистке стека от аргументов (например, `ADD SP, <количество аргументов * 2>`). Для понимания того, как должна быть устроена подпрограмма, следует разобраться в механизме работы `CALL`. По сути `CALL` совершает безусловный переход по заданной метке, как `JMP`. Однако если бы этим действие `CALL` ограничивалось, то невозможно было бы вернуться из подпрограммы обратно в место вызова («сделать обратный J(u)MP»). Чтобы было ясно, куда возвращаться, `CALL` кладёт на стек адрес следующей за ней инструкции. Это необходимо учитывать при доступе к аргументам подпрограммы: они оказываются на 2 байта глубже, чем хотелось бы, из-за лежащего на вершине стека адреса возврата (который разместила там `CALL`).

Теперь разберёмся как определяется подпрограмма. В самом простом случае она размещается в том же файле, что и основная программа, после инструкций, составляющих основную программу, которые завершаются системным вызовом `_EXIT`.

Подпрограмма начинается с метки, которая будет использоваться при вызове (`CALL`). Далее в подпрограмме могут идти любые инструкции, но обычно первым делом выполняются два действия, предназначенные для организации доступа к аргументам подпрограммы. Этот доступ организуется с помощью косвенной адресации со сдвигом через регистр `BP` (как в задаче 3). Для этого в `BP` заносится текущий указатель на вершину стека (тоже аналогично задаче 3). Однако сделать это первым же действием нельзя, так как процедура может быть вызвана из другой процедуры, которая использует `BP` для доступа к своим аргументам. Так что первым действием следует сохранить старое значение `BP` на стеке и только после этого заносить в `BP` текущее значение `SP`.

    MY_PROC:
            PUSH    BP
            MOV     BP, SP

Такая последовательность действий называется **прологом** подпрограммы. В конце подпрограммы следует восстановить старое значение `BP` и выполнить инструкцию `RET`, которая снимет с вершины стека адрес возврата и записывает его в регистр `PC`: программа продолжится с инструкции, следуюшей за `CALL` в основной прогармме. Если подпрограмме требуются какие-либо локальные переменные, они размещаются также на стеке, в таком случае перед завершением вершину стека следует переместить на то место, где она была после первой инструкции (`PUSH BP`). В этом случае завершение или **эпилог** подпрограммы выглядит так:

            MOV     SP, BP  ! можно опустить, если вершина стека
                            !   и так указывает на старое значение BP
            POP     BP
            RET

Обратите внимание на зеркальное подобие пролога и эпилога. Очень важно представлять, что происходит со стеком перед вызовом подпрограммы, во время вызова и по её завершении. В течение работы подпрограммы стек выглядит примерно так:

![](http://mmcs.sfedu.ru/~ulysses/Edu/CS221/pics/call-stack.png)

Здесь стек изображён растущим вниз, что соответствует указанному ранее принципу «стек растёт вниз». Однако следует учесть, что в окне t88 стек показан растущим вверх.

#### Задачи

1.  [`task-5.s`, 2.5 балла] Оберните решение задачи 2 в подпрограмму `PRINT_N`, которая печатает числа от 1 до _N_. Число _N_ передаётся как параметр на стеке. Следуя рисунку выше, при правильной организации подпрограммы доступ к _N_ осуществляется так: `4(BP)` (так как это первый и единственный аргумент). Основная программа (сразу после `.SECT .TEXT`) должна состоять из четырёх действий: 

    1. Положить на стек число 10 (значение параметра `N`). 
    2. Вызвать подпрограмму (`CALL`). 
    3. Очистить стек от числа 10. 
    4. Завершить программу системным вызовом `_EXIT`. 
    
    После основной программы идёт определение подпрограммы: метка с именем, пролог, цикл печати из задачи 2 (условие окончания цикла немного меняется: счётчик сравнивается не с 10, а с `4(BP)`), эпилог.

2.  [`task-6.s`, 3 балла] В этой задаче вам предлагается создать простейшую функцию. Функция отличается от процедуры наличием возвращаемого значения. Есть несколько вариантов размещения возвращаемого значения подпрограммы. Самый простой и одновременно широко используемый вариант (который примем и мы) — помещать возвращаемое значение в регистр `AX`. Создайте функцию сложения двух чисел (аргументы передаются через стек). В основной программе вызовите функцию и распечатайте её результат.

### Дополнительные задачи

1.  [`task-extra-1.s`] Добавление символа перехода на новую строку в подпрограмме из задачи 5 можно реализовать без помощи `printf`, а используя более простой системный вызов 122, который моделирует работу функции `putchar`. Она имеет единственный аргумент: символ, который необходимо вывести. Нужный символ можно класть на стек примерно так:

        PUSH 'a'

    (для размещения на стеке символа `a`). Организуйте печать символа перехода на новую строку с помощью системного вызова 122. Объявите для 122 именованную константу по аналогии с `_EXIT` и `_PRINTF`.
    
2.  [`task-extra-2.s`] Создайте процедуру печати всех элементов данного массива (передаётся адрес массива и его длина в словах).

3.  [`task-extra-3.s`] Создайте функцию суммирования всех элементов данного массива.

