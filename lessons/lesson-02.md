[//]: <> ( assignment id: 12467 )

### 1 Массивы [1 балл]

Принципы организации и обработки _массивов_ в языке ассемблера аналогичны языку C. Основная идея заключается в том, что массивом считается участок памяти, в котором **непрерывно** (друг за другом) размещены значения **фиксированного размера**. 

Пример объявления массива с инициализацией:

    .SECT .DATA
    arr:    .WORD   2, 5, 3, 8, 1   ! 5 элементов по 2 байта (WORD=2 байта)
    end:    .BYTE   0               ! метка конца массива для удобства вычисления размера

Многие задачи на обработку массивов связаны с организацией цикла, количество итераций которого равно длине массива. Для указания длины можно было бы использовать явное числовое значение (5 для массива `arr` из примера), однако рекомендуется вычислять это значение по формуле:

    <длина массива> = (<адрес конца> – <адрес начала>) / <размер элемента>

Адрес начала задаётся меткой перед объявлением массива (`arr` в примере выше). Адрес конца указывает любая метка, поставленная сразу после объявления массива; если таковой нет, то её вводят вместе с определением фиктивной переменной, как `end` в примере выше. В случае массива слов (`.WORD`) размер элемента равен двум байтам, а для деления на 2 удобно использовать битовый сдвиг вправо на одну позицию. Таким образом, для организации цикла по массиву с помощью `LOOP` необходимо сделать так:

            MOV     CX, end - arr
            SHR     CX, 1           ! shift right, деление на 2
    1:
            ! действия в цикле ...
            LOOP    1b

Обратите внимание на специальное имя метки для организации цикла: `1b` в инструкции
`LOOP` означает перейти к ближайшей сверху (**b**efore) метке с именем 1. Преимущество цифровых меток в том, что они могут повторяться в рамках одной программы, то есть можно не бояться конфликтов имён, как с обычными метками.

Для доступа к очередному элементу массива в самом простом случае удобно использовать _четвёртый режим адресации_ (помимо трёх, рассмотренных в первой лабораторной работе), а именно, **косвенную адресацию**. По форме она похожа на прямую адресацию в памяти: используются круглые скобки. Однако нужный адрес указывается не меткой, а хранится в одном из регистров: `BX`, `SI`, `DI`.

            MOV     BX, arr
            ADD     (BX), 3         ! добавили 3 к первому элементу массива
            ADD     BX, 2           ! переместились к следующему элементу массива
            SUB     (BX), 2         ! отняли 2 от второго элемента массива

Эта логика совершенно аналогична обработке массива в языке C с использованием указателя (`int * p = arr`), скользящего вдоль массива (`++p`) и выполняющего обращение к отдельным элементам с помощью разыменования (`*p`). Для организации цикла по массиву в языке ассемблера следует загрузить адрес начала массива в один из допустимых для косвенной адресации регистров (например, `BX`) и увеличивать значение этого регистра на два в конце каждой итерации цикла.

**Задача [task-1.s].** Напишите программу которая суммирует все элементы массива. Результат остаётся в регистре `AX`.

### 2 Моделирование условного оператора [1.5 балла]

#### Часть 2.1 `CMP` + `J**`

Условный оператор в языке ассемблера Intel 8088 моделируется с помощью группы [инструкций условных переходов `J**`](http://mmcs.sfedu.ru/~ulysses/Edu/CS221/pics/jmp.png) (сравнение на больше, меньше, больше или равно и т.п.), каждая из которых принимает один операнд — имя метки, к которой осуществляется переход при выполнении нужного условия. Этим инструкции `J**` похожи на инструкцию `LOOP`. Конкретные величины, которые сравниваются, задаются в инструкции `CMP`, которую следует использовать перед `J**`.

Пример кода, который увеличивает значение регистра `BX` на 1, если значение в регистре `AX` больше пяти:

            CMP     AX, 5
            JLE     LIF     ! LE = less or equal: если AX <= 5 "перепрыгиваем" (**j**ump) INC
            INC     BX
    LIF:
            ! продолжение программы...

**Задача [task-2.s].** Напишите программу, которая суммирует все числа массива, больше или равные _N_, где _N_ = 3 — переменная, заданная в секции данных. **Указание:** обращаться в память по метке _N_ на каждом шаге цикла неэффективно, перед началом цикла загрузите значение _N_ в один из свободных регистров.

#### Часть 2.2 Что-угодно + `J**`

Важно разобраться, как устроены инструкции `J**`, а именно каким образом они получают информацию от инструкции сравнения `CMP`. В процессорах Intel x86 существует специальный **регистр флагов**, в котором каждый бит имеет имя и представляет собой специальное условие (является флагом). Примеры флагов, связанных с арифметическими операциями: 

* ZF — флаг нуля (zero), 
* CF — флаг переноса (carry), 
* SF — знаковый флаг (sign), 
* OF — флаг переполнения (overflow). 

Следить за значением этих флагов можно в окне трасёра `t88`. Большинство арифметических инструкций кроме выполнения нужной операции взводят соответствующие флаги. Инструкция `CMP` устроена аналогично, она выполняет вычитание второго операнда из первого, результат отбрасывается, но взводятся соответствующие флаги.

Инструкции `J**` анализируют лишь текущее состояние флагов. Однако имена этих инструкий даны так, что при использовании команды `CMP` результат анализа флагов точно отражается их именами. В этом случае программисту можно вообще ничего не знать про существование флагов. Однако часто бывает удобно (и более эффективно) использовать другие инструкции, взводящие флаги, и на их основе выполнять переходы `J**`. В этом случае нужно разобраться, какие флаги затрагивает используемая арифметическая инструкция и какие из команд `J**` анализируют именно эти флаги.

**Задача [task-3.s].** Напишите программу, которая суммирует все чётные числа массива. Для проверки чётности используйте деление на 2 с помощью `SHR`: проследите, какой флаг может взводится этой командой в случае нечётных или чётных чисел и найдите [в приведённой выше таблице](http://mmcs.sfedu.ru/~ulysses/Edu/CS221/pics/jmp.png) инструкцию `J**`, которая анализирует именно этот флаг. [Картинка, где показано расположение флагов в окне t88](http://mmcs.sfedu.ru/~ulysses/Edu/CS221/pics/flags.png), поможет вам понять, за какой частью окна отладчика нужно следить при выполнении `SHR`. Решение этой задачи удобно писать на основе решения `task-2.s`.

#### Часть 2.3 Полная форма условного оператора

В предыдущих задачах на условные переходы моделировалась сокращённая форма условного оператора (без ветки `else`). Для получения полной формы в комбинации с одной инструкцией `J**` используется инструкция безусловного перехода `JMP`. Модифицируем первый пример на условные переходы.

            CMP     AX, 5
            JLE     1f      ! f = forward, прыжок вперёд
            INC     BX      ! ветка then  (если AX > 5)
            JMP     2f      ! безусловный переход к концу "условного оператора"
    1:
            DEC     BX      ! ветка else (уменьшаем BX, если AX <= 5)
    2:
            ! продолжение программы...

**Задача [task-4.s].** Напишите программу, которая отдельно суммирует все числа массива, больше или равные _N_, где _N_ = 3 — переменная, заданная в секции данных, и отдельно суммирует числа, меньшие _N_. Первый и второй результат в конце программы должны находиться в `AX` и `BX` соответственно. Указание: выполнять на основе решения `task-2.s`.

### 3 Организация циклов с помощью условных переходов [0.5 балла]

Выше отмечалось, что инструкции `J**` аналогичны `LOOP`. Легко заметить, что с помощью инструкций `J**` тоже можно организовывать циклы. На самом деле, промышленные компиляторы практически никогда не генерируют инструкцию `LOOP` для организации цикла, а всегда обходятся `J**`. Это связано с тем, что `LOOP` занимает один регистр (`CX`) и использует его строго определённым образом, который не слишком удобен для большинства задач. В таком случае этот регистр просто «потерян» для программиста (или компилятора). Замена `LOOP` на `J**` позволяет избежать этого и более эффективно использовать имеющиеся регистры.

**Задача [task-5.s].** Напишите программу, которая вычисляет значение выражения 4 _x_<sup>2</sup> – _x_ % 3 для _x_ = 4, 8, 12. **Указания.** Не использовать `LOOP`. Выбрать регистр для хранения очередного значения _x_ и делать переход `J**` к началу тела цикла пока значение этого регистра меньше или равно 12. Для умножения на 4 используйте битовый сдвиг влево `SHL`: для сдвига на 2 и более (до 15) величину сдвига следует передавать в регистре `CL` (нижняя половинка регистра `CX`), чтобы загрузить в `CL` двойку, следует использовать инструкцию `MOVB` (B от **byte**).

### Дополнительные задачи

Во всех задачах «найти» означает поместить в `AX` к концу программы.

1.  [task-extra-1.s] Напишите программу, которая находит минимум в заданном массиве. **Указание.** Удобно до начала цикла инициализировать регистр для хранения текущего минимума максимальным положительным 16-разрядным числом, то есть `0x8FFF` — это число с единственным нулевым битом в старшем («знаковом») разряде (обратите внимание, что шестнадцатеричная система более удобна для записи таких чисел, чем десятичная).

2.  [task-extra-2.s] Напишите программу, которая находит минимальный из чётных элементов массива. 

3.  [task-extra-3.s] Найти первый элемент массива кратный четырём. Указание: можно использовать LOOP, но в теле цикла при нахождении нужного элемента делать переход J** из тела цикла к первой инструкции после цикла. Если в вашей программе после цикла не нужно делать ничего, то после цикла можно вставить помеченную инструкцию NOP (No OPeration — отсутствие действия).

