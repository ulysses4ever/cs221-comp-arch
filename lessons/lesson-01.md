[//]: <> ( assignment id: 6011 )

### 1  Структура программы на языке ассемблера Intel 8088 [1 балл]

Структура программы выглядит следующим образом:

    .SECT .TEXT
    ! <последовательность инструкций процессора>
    .SECT .DATA
    ! <последовательность команд ассемблера выделения памяти с инициализацией>
    .SECT .BSS
    ! <последовательность команд выделения памяти без инициализации>

Последние две секции могут быть пустыми, но заголовки всё равно должны присутствовать. Первая секция предназначена для написания кода, вторые две — для хранения статических данных, это полный аналог глобальных переменных в высокоуровневых языках программирования вроде C.

Пример последовательности инструкций для сложения двух чисел 2 и 3:

    MOV    AX, 2
    ADD    AX, 3

Сначала в регистр `AX` помещается (`MOV`) двойка (регистрами называется быстрые именованные элементы памяти на процессере, куда помещаются операнды). Затем к содержимому `AX` добавляется тройка. Смысл инструкций `MOV` и `ADD` легко запомнить, если применять следующую мнемонику: большинство арифметических инструкций аналогичны присваивающим формам арифметических операций в C (в частном случае, `MOV` аналогичен операции присваивания). То есть код выше можно было бы перевести на C следующим образом (считая `AX` обычной переменной):

    AX =  2
    AX += 3

Попробуйте сассемблировать (с помощью `as88`) и выполнить по шагам (с помощью `t88`) программу, приведённую выше. Для этого нужно создать текстовый файл (назовём его `task-0.s`) с объявлением всех трёх секций и с двумя указанными инструкциями в секции кода. В ходе отладки проследите изменение значений регистра `AX`. После выполнения обеих инструкций (клавиша `Enter`) и проверки значения регистра `AX` завершите работу отладчика командой `q`.

**Замечание по оформлению кода (правило «четырёх столбцов»).** Код
рекомендуется оформлять в 4 столбца: столбец меток, столбец инструкций
и команд ассемблера, столбец операндов, комментарии. Это правило используется,
даже если столбец пуст (например, первая колонка с метками
почти всегда пуста и потому инструкции пишутся с отступом). Исключением
являются начала секций — директива `.SECT` идёт без отступа. Столбцы
разделяются достаточным для визуального разделения количеством нажатий
Tab (1 или 2 в зависимости от настроек редактора), желательно, чтобы визуально 
это соответствовало 8 пробелам. Между секциями следует оставлять пустые строки.

Помните, что выполнение требований по оформлению и именованию файлов оценивается.

### 2  Режимы адресации [1 балл]

Под термином _режимы адресации_ в языках ассемблеров понимается способ передачи («адресация») операндов инструкций, перечислим основные из этих способов.

1.  _Непосредственная адресация («непосредственные операнды»)_ — операнд передаётся процессору прямо вместе с инструкцией. Как 2 и 3 в примере выше.

2.  _Регистровая адресация_ — операнд находится в указанном регистре процессора (пока мы использовали один регистр — `AX`).

3.  _Прямая адресация в памяти_ — операнды располагаются в оперативной памяти
(в наших примерах чаще всего — в сегменте данных) по
известному на этапе ассемблирования адресу. Такой адрес обычно задаётся с помощью символического имени: «метки». Ниже приводится соответствующий пример.

        .SECT .TEXT
                MOV     AX, (x)
                ADD     AX, (y)

        .SECT .DATA
        x:     .WORD    2
        y:     .WORD    3

        .SECT .BSS

В данном примере суммируемые значения размещены в сегменте данных по **меткам** `x` и `y`. Метка отделяется от команды двоеточием. Метка очень похожа на константный указатель C++: она представляет адрес нужного значения (в примере `x` это адрес значения 2, `y` это адрес значения 3). Для обращения по этому адресу используется запись `(x)`, `(y)` и т. п. (аналогично операции разыменования указателя `*` в C). Часто для краткости метки наподобие `x` и `y` называют «переменными», хотя это не полностью отражает их смысл.

1.  [`task-1.s`, вычитание] Создайте программу, которая вычитает из числа 3 число 2 по аналогии с примером выше (числа размещены в сегменте данных). Инструкция вычитания `SUB` получает операнды полностью аналогично `ADD`.

2.  [`task-2.s`, запись результата] Добавьте в предыдущую программу (используйте команду текстового редактора «Сохранить как…» из меню «Файл») к переменным `x` и `y` переменную `res`. Поскольку у `res` нет исходного значения, её разумно поместить в секции неинициализированных данных `BSS`. В этой секции вместо команды `.WORD` следует использовать команду `.SPACE`, после которой указывается количество байт под переменную. Все целочисленные значения имеют размер 2 байта.

    После получения результата в регистре `AX` скопируйте содержимое `AX` в `res` с помощью инструкции `MOV`. **Чтобы следить в отладчике за изменением памяти по метке** `res`, можно использовать команду:

        /res

    (её нужно ввести после запуска `t88`).

3. Не все комбинации режимов адресации допустимы. Рассмотрим несколько вариантов.
    Если при выполнении возникают ошибки ассемблирования, запишите в файл с 
    программой **в комментарии (после символа ! до конца строки)** текст ошибки
    и переходите к следующему.

    Будем пытаться решить предыдущую задачу (`task-2.s`) без использования 
    регистра `AX`. 

    *Вариант 1* (`task-3-1.s`). Поместить (с помощью `MOV`) в `res` число 3, а затем вычесть из `res` число 2 (числа 2 и 3 — непосредственные операнды). 

    *Варианты 2 и 3*. Данные в секции `BSS` инициализируются нулями, потому чтобы получить в `res` исходную 3 можно воспользоваться `ADD` (прибавляем к 0 число 3). Затем вычитаем из `res` число 2 (числа 2 и 3 — непосредственные операнды). Напишите два варианта этой логики: 
    
    * когда для вторых операндов `ADD` и `SUB` (3 и 2) используется прямая адресация в памяти (`task-3-2.s`),
    *  когдая для этих операндов непосредственные операнды (`task-3-3.s`). В случае неудачи в каком-то из случаев добавьте текст ошибки ассемблирования в комментарии.

4.  [`task-4.s`, значения меток] Метки представляют собой константные адреса, то есть целые числа, которые при том определены на этапе ассемблирования — а значит, при каждом запуске программы они будут одинаковыми. По сути это просто символические константы аналогично `#define` в C.

    Загрузите в регистры `AX`, `BX` и `CX` значения меток `x`, `y`, `res` (**не путать со значениями ПО меткам**), объявленных как в программе из позапрошлой задачи (`task-2.s`): используйте `MOV` и имена меток без круглых скобок. Проанализируйте полученные значения. Добавьте после `x` переменную `x1` (то есть метку `x1` и ещё одну инструкцию `.WORD` с каким-либо значением для инициализации). Как изменились значения меток? Ответ запишите в комментариях (допускаются только латинские буквы).

### 3  Простейшие арифметические команды [1 балл]

1.  [`task-5.s`, умножение] Инструкция умножения `MUL` имеет отличный от `ADD` и `SUB` интерфейс. Она имеет один (явный) операнд, он играет роль одного из сомножителей. Второй сомножитель берётся этой инструкцией (неявно) из регистра `AX`. Результат умножения может не поместиться в один регистр, потому для него используется пара регистров: младшие 16 бит результата помещаются в регистр `AX`, старшие — в `DX`. На занятиях мы будем работать с маленькими числами, потому регистр `DX` нас волновать не будет, однако такое устройство инструкции `MUL` может приводить к проблемам, если в регистре `DX` хранится некая полезная информация — после выполнения `MUL` она непременно затрётся (если результат умножения положителен и поместился в 16 бит, то в `DX` попадут нули). А потому программист должен сохранить полезную информацию из `DX` в каком-либо месте перед использованием `MUL` — в переменной или в другом регистре.

    Следуя данному описанию составьте программу, которая перемножает два числа, 2 и 3, заданные в сегменте данных, и помещает результат в переменную `res`, объявленную в секции `BSS`.

2.  [`task-6.s`, целочисленное деление] Инструкция целочисленного деления `DIV` имеет аналогичный `MUL` интерфейс. Так же используется один явный параметр, играющий роль делителя. Делимое считается 32-битным и берётся из пары регистров `DX:AX` (старшие биты в DX). Если делимое помещается в 16 бит, то его нужно загрузить в регистр AX, а в DX забивается 1-битами, если делимое отрицательно и 0-битами в противном случае (такая операция называется _знаковым расширением_). Для этого непосредственно **перед ****использованием инструкции DIV следует передать инструкцию CWD** (Convert Word to Doubleword) без операндов. Вновь следует помнить о том, что хранившаяся в `DX` информация будет утеряна.

    Частное от деления помещается в регистр `AX`, а остаток от целочисленного деления — в `DX`.

    Следуя данному описанию составьте программу, которая вычисляет сумму: `55 / 10 + 55 % 10` и помещает результат в переменную `res`, объявленную в секции `BSS`. (Здесь и далее `/` означает целочисленное деление, а `%` — остаток от целочисленного деления).

3.  [`task-7.s` простейший цикл с `LOOP`] Для организации циклов используются метки в сегменте кода и специальные инструкции перехода по этим меткам. Простейшая из таких инструкций — `LOOP`:

                MOV     CX, (n)     ! количество шагов загружаем в CX —
                                    !   это требование LOOP
        L1:     ADD     AX, (x)
                LOOP    L1          ! уменьшает CX на 1, и если CX не равен 0,
                                    !   то переходит по метке L1

    этот код `(n)` раз прибавляет к `AX` значение `(x)` (предполагается, что `n` и `x` это метки из сегмента данных, указывающие на некоторые числа).

    Следуя данному описанию составьте программу, которая считает сумму `5 + 10 + 15 + 20 + 25`. Очередное слагаемое удобно хранить в отдельном регистре (например, `BX`) и увеличивать его на 5 на каждом шаге цикла.

### 4  Дополнительные задачи

1.  Вычислите значение многочлена $2x^4 - 3x^2 + x - 5$ в точке _x_ = 7 (задано в сегменте данных). Указание: четвёртая степень _x_ должна вычисляться с помощью возведения в квадрат второй.

2.  Вычислите значение выражения $3x^4 / 8 - x^3 \% 5 + x - 1$ в точках _x_ = 3, 6, 9 (в цикле LOOP).

3.  Скачайте пример `Hello-World`, сассемблируйте и запустите его с помощью симулятора `s88`. Модифицируйте текст программы так, чтобы надпись выводилась на экран 10 раз. Указание: для выполнения задачи достаточно добавить `LOOP` в нужном месте, при этом не требуется детально разбираться с текстом программы.

