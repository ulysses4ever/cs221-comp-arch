[//]: <> ( assignment id: 13177 )

**Скачайте [набор микропрограммиста](http://staff.mmcs.sfedu.ru/~ulysses/Edu/CS221/mic-1/Mic1MMV.zip)** на архитектуре Mic-1\. Распакуйте архив в домашний каталог, откройте в терминале распакованный каталог Mic1MMV. Запустите графический симулятор Mic-1 командой:

    $ java -jar Mic1MMV.jar

Данный симулятор предназначен для интерпретации инструкций IJVM на микроархитектуре Mic-1\. Задача лабораторной работы состоит в расширении набора инструкций IJVM и реализации новых инструкций на микропрограммном уровне с помощью микроассемблера MAL. [Схема работы может быть представлена графически](http://staff.mmcs.sfedu.ru/~ulysses/Edu/CS221/mic-1/diag.png) — посмотрите на неё. Упомянутые программы (IJVM-ассемблер и MAL) спрятаны внутри данного графического симулятора.

**Для решения каждой задачи нужно выполнить одну и ту же последовательность действий:**

1.  Скачать .jas-файл с программой (будет дан в задаче) на ассемблере IJVM, где используется новая инструкция IJVM, которую нужно реализовать в данной задаче. Имеет смысл заглянуть внутрь файла.

2.  Добавить в описание ассемблера IJVM (файл ijvm-mmcs.conf из архива) имя новой инструкций и её код (вообще говоря, произвольный новый, но в задаче он будет указан).

3.  Добавить в микропрограмму (файл mic1mmv-mmcs.mal из архива) последовательность микрокоманд, реализующих новую инструкцию.

4.  Перезапустить симулятор из консоли (это заставит его прочитать обновления в .conf-файле для IJVM). Сассемблировать и загрузить файл с модифицированной микропрограммой (mic1mmv-mmcs.mal, команда меню симулятора File → Assemble / Load MAL file), сассемблировать и загрузить файл с программой, скаченной на первом шаге (команда меню симулятора File → Assemble / Load JAS file).

5.  Запустить симуляцию (см. ниже).

У симулятора есть несколько режимов («скоростей» — найдите слово **Speed** в окне симулятора) работы, от выбора скорости зависит то, какое количество действий выполняется за одно нажатие синей стрелочки вправо:

*   SubClock — по фазе («подциклу») одного цикла (запуск шины B, запуск АЛУ, запуск шины C и запись в регистры — три вида подциклов внутри одного цикла);
*   Clock — по одной микрокоманде (одному «циклу»);
*   IJVM — по одной инструкции процессора;
*   Prog — непрерывно (до конца программы или до очередной операции ввода с клавиатуры).

К большому сожалению переключение между скоростями не доступно по ходу выполнения программы. Поэтому разумный **алгоритм проверки правильности решения** на данном симуляторе выглядит так:

1.  Первый запуск программы проводить на скорости Prog. Результат в выданных .jas-программах всегда будет помещаться на стек и в конце выполнения программы будет видно, правильное там оказалось значение или нет (вершина стека выделена красным в поле Stack Area). Если оно правильное, то можно решать следующую задачу.

2.  Если значение на стеке неправильное, то нужно переключиться на скорость Cycle (или даже Subcycle) и выполнять программу по шагам, наблюдая за тем, какие выполняются микрокоманды (видно в поле под переключателем скоростей) и как изменяются значения регистров. Это позволит найти ошибку в вашей микропрограмме, хотя понадобится много нажатий на синюю стрелочку вправо.

3.  В начале работы программы выполняются три стандартных цикла (`Main1 | nop1 | Main1`), которые позволяют подхватить из памяти первую инструкцию этой программы — не пугайтесь и пропускайте их.

В качестве напоминания назначение основных регистров Mic-1 описано на [данной странице](http://it.mmcs.sfedu.ru/wiki/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5_%D1%80%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D1%8B_Mic-1), остальные регистры здесь не понадобятся.

### Задачи

1.  [1 балл] [Скачайте программу](http://staff.mmcs.sfedu.ru/~ulysses/Edu/CS221/mic-1/dec.jas), использующую новую инструкцию DEC [предлагаемый код: 0x16], которая уменьшает слово на вершине стека на единицу. Выполните необходимые действия для микропрограммной реализации этой инструкции (см. первый список на этой странице сверху).   

    **Идеи.** Действуйте по аналогии с с тем, что уже есть в .conf и .mal-файлах.
    1.  В .conf-файл добавляется имя новой инструкции (DEC) и её код. 
    2.  В .mal-файле нужно не забыть вставить директиву .label, которая жёстко задаёт адрес микрокоманды с заданной меткой. Это делается для выполнения условия: адрес первой микрокоманды для выполнения инструкции X должен совпадать с бинарным кодом X.
    3.  Алгоритм для микропрограммы: уменьшить содержимое TOS на 1 и результат записать в TOS и в MDR (в MDR — для будущего «сброса» в память: вершина стека хранится в двух местах, в TOS и в памяти по адресу SP). Загрузить в MAR значение SP и вызвать команду wr, чтобы записать новое значение вершины стека в память. В этом же месте сделать goto Main1 (делается в конце каждого отрезка микрокоманд для каждой инструкции — это можно видеть в файле).
2.  [1.5 балла] [Скачайте программу](http://staff.mmcs.sfedu.ru/~ulysses/Edu/CS221/mic-1/add3-light.jas), использующую новую инструкцию IADD3 [предлагаемый код: 0x20], которая берёт со стека три числа и кладёт на стек их сумму. Выполните необходимые действия для микропрограммной реализации этой инструкции.   

    **Идеи.** Действуйте по аналогии с реализацией стандартной инструкции IJVM по имени **IADD**.
    1.  Имя метки первой микрокоманды удобно выбрать таким: iadd31\. Последующие инструкции отмечать iadd32, iadd33 и т. д. (повторим: см. реализацию IADD, которая выполнена командами iadd1, iadd2, iadd3, свою реализацию разместите под iadd3 через пустую строку).
    2.  Поскольку требуется три числа со стека, одно из которых (вершина) уже есть в регистре TOS, то потребуется два чтения из памяти (rd).
    3.  Решение этой задачи может уложиться в пять микрокоманд (может, есть и более короткое решение) без пустых циклов ожидания данных из памяти. Для этого нужно вспомнить, что чтение из памяти (команда rd) занимает ровно один цикл. Это, в частности, значит что на следующем после вызова rd цикле ещё можно использовать старое значение MDR — эта хитрая идея позволяет уложится в пять циклов. Если она не ясна, скорее всего придётся вставлять дополнительные пустые циклы для ожидания подгрузки данных из памяти (пустой цикл вставляется так: пишется метка, например, iadd32, а затем переход на новую строку и следующий цикл, уже непустой).
3.  [2 балла] [Скачайте программу](http://staff.mmcs.sfedu.ru/~ulysses/Edu/CS221/mic-1/umul.jas), использующую новую инструкцию UMUL [выберите любой свободный код инструкции], которая перемножает два слова, лежащие на стеке, и кладёт результат на стек в предположении, что исходные два слова представляют неотрицательные числа. Выполните необходимые действия для микропрограммной реализации этой инструкции.  

    **Идеи. **
    1.  Умножение реализуется через многократное сложение.
    2.  Будет несколько инструкций типа goto _label_.
    3.  Для организации цикла на микропрограммном уровне следует использовать goto, условие остановки реализуется с помощью микрокоманды:   
        Z = регистр; if (Z) goto метка_выхода_из_цикла; else goto метка_начала_цикла  

4.  [3 балл] Добавьте в набор инструкций IJVM инструкцию POPN с одним однобайтовым аргументом, эта инструкция должна снимать со стека _N_ слов, где _N_ это значение аргумента. Составьте jas-программу, которая использует эту инструкцию — например, кладёт три значения на стек, а потом вызывает POPN 3\. Идеи для микропрограммной реализации стоит брать из реализации POP и реализации любой инструкции с однобайтовым параметром, например, BIPUSH.

#### Дополнительные задачи

1.  Реализуйте инструкцию-префикс rep, которая ставится перед любой другой инструкцией _X_ без аргументов и повторяет инструкцию _X_ количество раз, заданное значением на вершине стека. При этом в качестве X могут следовать лишь те инструкции, которые после своей работы оставляют на вершине стека такое же значение, как было перед их вызовом.  

    **Идеи?** В реализации после анализа оставшегося количества повторений стоит переходить по коду, лежащему в MBR (это будет код следующий за rep, то есть код инструкции _X_). Анализ количества повторений состоит в следующем: если число, лежащее на стеке, не равно нулю, то следует сдвинуть счётчик инструкций PC на один назад и сделать fetch. Это заставит снова подхватить в MBR инструкцию rep и именно она станет снова выполняться после выполнения _X_. Важно, что этот fetch поменяет MBR только к концу следующего цикла и переход по коду, лежащему в MBR на момент начала обработки rep, будет выполнен корректно.  

2.  Реализуйте инструкцию деления двух положительных чисел с вершины стека, в результате на стек следует поместить два значения: частное и остаток от целочисленного деления.
3.  [Скачайте jas-программу](http://edu.mmcs.sfedu.ru/mod/resource/view.php?id=6626) сложения двух чисел, введённых с клавиатуры. Модифицируйте её так, чтобы вводилось три числа и сложение осуществлялось с помощью IADD3\. А также замените длинные серии команд DUP и OUT на REP DUP и REP OUT соответственно.
